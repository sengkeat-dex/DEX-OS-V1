//! Fee management implementation for the DEX-OS core engine
//!
//! This module implements the Priority 2 feature from DEX-OS-V1.csv:
//! "Core Trading,AMM,AMM,Priority Queue,Fee Claims,Medium"
//!
//! It provides functionality for tracking and claiming fees generated by
//! liquidity provision in AMM pools.

use crate::types::{TokenId, Quantity, TraderId};
use std::collections::BinaryHeap;
use std::cmp::Ordering;
use thiserror::Error;

/// Represents a fee claim that can be processed
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct FeeClaim {
    /// Priority of the claim (higher values processed first)
    pub priority: u64,
    /// Trader who is claiming the fees
    pub trader_id: TraderId,
    /// Token being claimed
    pub token_id: TokenId,
    /// Amount of fees to claim
    pub amount: Quantity,
    /// Timestamp when the claim was created
    pub timestamp: u64,
}

impl Ord for FeeClaim {
    fn cmp(&self, other: &Self) -> Ordering {
        // Higher priority values come first
        self.priority.cmp(&other.priority)
            .then_with(|| other.timestamp.cmp(&self.timestamp))
    }
}

impl PartialOrd for FeeClaim {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

/// Manages fee claims using a priority queue
#[derive(Debug, Clone)]
pub struct FeeClaimManager {
    /// Priority queue of fee claims
    claims: BinaryHeap<FeeClaim>,
}

impl FeeClaimManager {
    /// Create a new fee claim manager
    pub fn new() -> Self {
        Self {
            claims: BinaryHeap::new(),
        }
    }

    /// Add a new fee claim to the queue
    pub fn add_claim(&mut self, claim: FeeClaim) {
        self.claims.push(claim);
    }

    /// Process the next fee claim (highest priority)
    pub fn process_next_claim(&mut self) -> Option<FeeClaim> {
        self.claims.pop()
    }

    /// Get the number of pending fee claims
    pub fn pending_claims_count(&self) -> usize {
        self.claims.len()
    }

    /// Check if there are any pending fee claims
    pub fn has_pending_claims(&self) -> bool {
        !self.claims.is_empty()
    }

    /// Get a reference to the highest priority claim without removing it
    pub fn peek_next_claim(&self) -> Option<&FeeClaim> {
        self.claims.peek()
    }
}

/// Errors that can occur during fee management operations
#[derive(Debug, Error)]
pub enum FeeManagementError {
    #[error("No pending fee claims")]
    NoPendingClaims,
    #[error("Invalid claim priority")]
    InvalidPriority,
    #[error("Insufficient fees available for claim")]
    InsufficientFees,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_fee_claim_manager_creation() {
        let mut manager = FeeClaimManager::new();
        assert_eq!(manager.pending_claims_count(), 0);
        assert!(!manager.has_pending_claims());
        assert!(manager.peek_next_claim().is_none());
        assert!(manager.process_next_claim().is_none());
    }

    #[test]
    fn test_add_and_process_claims() {
        let mut manager = FeeClaimManager::new();
        
        // Add some fee claims
        let claim1 = FeeClaim {
            priority: 10,
            trader_id: "trader1".to_string(),
            token_id: "BTC".to_string(),
            amount: 1000,
            timestamp: 1000000,
        };
        
        let claim2 = FeeClaim {
            priority: 20,
            trader_id: "trader2".to_string(),
            token_id: "ETH".to_string(),
            amount: 2000,
            timestamp: 1000001,
        };
        
        let claim3 = FeeClaim {
            priority: 15,
            trader_id: "trader3".to_string(),
            token_id: "USDC".to_string(),
            amount: 1500,
            timestamp: 1000002,
        };
        
        manager.add_claim(claim1.clone());
        manager.add_claim(claim2.clone());
        manager.add_claim(claim3.clone());
        
        assert_eq!(manager.pending_claims_count(), 3);
        assert!(manager.has_pending_claims());
        
        // Process claims - should be processed in priority order (20, then 15, then 10)
        let processed_claim = manager.process_next_claim().unwrap();
        assert_eq!(processed_claim.priority, 20);
        assert_eq!(processed_claim.trader_id, "trader2");
        
        let processed_claim = manager.process_next_claim().unwrap();
        assert_eq!(processed_claim.priority, 15);
        assert_eq!(processed_claim.trader_id, "trader3");
        
        let processed_claim = manager.process_next_claim().unwrap();
        assert_eq!(processed_claim.priority, 10);
        assert_eq!(processed_claim.trader_id, "trader1");
        
        // No more claims
        assert!(manager.process_next_claim().is_none());
        assert_eq!(manager.pending_claims_count(), 0);
    }

    #[test]
    fn test_peek_next_claim() {
        let mut manager = FeeClaimManager::new();
        
        // Initially no claims
        assert!(manager.peek_next_claim().is_none());
        
        // Add a claim
        let claim = FeeClaim {
            priority: 10,
            trader_id: "trader1".to_string(),
            token_id: "BTC".to_string(),
            amount: 1000,
            timestamp: 1000000,
        };
        
        manager.add_claim(claim.clone());
        assert_eq!(manager.peek_next_claim().unwrap().priority, 10);
        assert_eq!(manager.pending_claims_count(), 1);
        
        // Peek doesn't remove the claim
        assert_eq!(manager.peek_next_claim().unwrap().priority, 10);
        assert_eq!(manager.pending_claims_count(), 1);
    }

    #[test]
    fn test_same_priority_ordering() {
        let mut manager = FeeClaimManager::new();
        
        // Add claims with same priority but different timestamps
        let claim1 = FeeClaim {
            priority: 10,
            trader_id: "trader1".to_string(),
            token_id: "BTC".to_string(),
            amount: 1000,
            timestamp: 1000000, // Earlier timestamp
        };
        
        let claim2 = FeeClaim {
            priority: 10,
            trader_id: "trader2".to_string(),
            token_id: "ETH".to_string(),
            amount: 2000,
            timestamp: 1000001, // Later timestamp
        };
        
        manager.add_claim(claim2.clone());
        manager.add_claim(claim1.clone());
        
        // Claim with earlier timestamp should be processed first when priorities are equal
        let processed_claim = manager.process_next_claim().unwrap();
        assert_eq!(processed_claim.timestamp, 1000000);
        assert_eq!(processed_claim.trader_id, "trader1");
        
        let processed_claim = manager.process_next_claim().unwrap();
        assert_eq!(processed_claim.timestamp, 1000001);
        assert_eq!(processed_claim.trader_id, "trader2");
    }
}